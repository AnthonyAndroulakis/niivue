<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>NiiVue</title>
    <link rel="stylesheet" href="niivue.css" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=" />
  </head>
  <body>
    <noscript>
      <strong>niivue requires JavaScript.</strong>
    </noscript>
    <header>
      <select id="sliceDrop">
        <option value="0">Axial</option>
        <option value="1">Coronal</option>
        <option value="2">Sagittal</option>
        <option value="4">Render</option>
        <option value="3" selected>A+C+S+R</option>
      </select>
      <button id="saveBtn">save volume</button>
    </header>
    <main id="canvas-container">
      <canvas id="gl1"></canvas>
    </main>
    <footer>
    <footer id="intensity">&nbsp;</footer>
    </footer>
    <script type="module" async>
      import { encode } from 'cbor-x'
      import {
        iwm2mesh,
        iwi2nii,
        nii2iwi,
        mesh2iwm,
      } from "./itk2cbor.js"
      import {
        Niivue,
        NVImage,
        NVMesh,
        NVMeshLoaders,
        NVMeshUtilities,
        SHOW_RENDER
      } from "./niivue/index.ts"
      import {
  downsampleBinShrink,
  downsampleLabelImage,
  downsampleSigma,
  downsample,
  gaussianKernelRadius,
  setPipelinesBaseUrl,
  getPipelinesBaseUrl,
} from "@itk-wasm/downsample"
import { niftiReadImage } from "@itk-wasm/image-io"
      sliceDrop.onchange = function () {
        let st = parseInt(this.value)
        nv1.setSliceType(st)
      }
      function handleIntensityChange(data) {
        document.getElementById("intensity").innerHTML =
          "&nbsp;&nbsp;" + data.string
      }
      saveBtn.onclick = function () {
        nv1.saveImage({ filename: 'test.nii', isSaveDrawing: false, volumeByIndex: 0})
      }
      let defaults = {
        backColor: [0, 0, 0, 1],
        show3Dcrosshair: true,
        onLocationChange: handleIntensityChange
      }
      var nv1 = new Niivue(defaults)
      nv1.attachToCanvas(gl1)
      async function loadBinaryFile(url) {
          try {
              const response = await fetch(url)
              if (!response.ok) {
                  throw new Error(`Failed to load file: ${response.statusText}`)
              }
              return await response.arrayBuffer()
          } catch (error) {
              console.error('Error loading binary file:', error)
          }
      }
      async function loadIWM(url) {
        const arrayBuffer = await loadBinaryFile(url)
        let mesh = iwm2mesh(arrayBuffer)
        const mz3 = NVMeshUtilities.createMZ3(mesh.positions, mesh.indices, false)
        await nv1.loadFromArrayBuffer(mz3, 'test.mz3')
      }
      async function loadIWI(url) {
        const arrayBuffer = await loadBinaryFile(url)
        let nii = iwi2nii(arrayBuffer)
        await nv1.loadVolumes([{ url: nii, name: 'test.nii' }])
      }
      async function createIWI() {
        const iwi = nii2iwi(nv1.volumes[0].hdr,  nv1.volumes[0].img.buffer)
        const iwiEncoded = nii2iwi(nv1.volumes[0].hdr,  nv1.volumes[0].img.buffer, true)
        let nii = iwi2nii(iwiEncoded)
        await nv1.loadVolumes([{ url: nii, name: 'test.nii' }])
        console.log('dims before downsample')
        console.log(nv1.volumes[0].dims)
        await doDownsample(iwi, new File([nii], 'test.nii'))
      }
      async function createIWM() {
        let iwm = mesh2iwm(nv1.meshes[0].pts, nv1.meshes[0].tris)
        let mesh = iwm2mesh(iwm)
        const mz3 = NVMeshUtilities.createMZ3(mesh.positions, mesh.indices, false)
        await nv1.loadFromArrayBuffer(mz3, 'test.mz3')
      }
      async function doDownsample(inFile, nii){
        let readFileResult = await niftiReadImage(nii)
        // bigint -> number is necessary for serialization because the object is serialized to JSON
        // to be sent to the worker and the JSON does not support bigint.
        // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json
        inFile.size = inFile.size.map(Number)
        console.log('doing downsampling')
        console.log('inFile nifti parsed with itk-wasm niftiReadImage')
        console.log(readFileResult.image)
        console.log('inFile from nii2iwi (for comparison)')
        console.log(inFile)
        const downSampleResult = await downsampleBinShrink(inFile, {
          shrinkFactors: [2, 2, 2],
          webWorker: null
        })
        const downSampledImage = downSampleResult.downsampled
        console.log('downSampledImage')
        console.log(downSampledImage)
        // number -> bigint because encode expects Image class to have bigint size
        downSampledImage.size = downSampledImage.size.map(BigInt)
        // must incode the downsampled image to cbor to work 
        // with iwi2nii implementation
        const downNii = iwi2nii(encode(downSampledImage))
        await nv1.loadVolumes([{ url: downNii, name: 'test.nii' }])
        console.log('dims after downsample')
        console.log(nv1.volumes[0].dims)
      }

      async function main(){
        await loadIWI('./fslmean.iwi.cbor')
        await loadIWM('./cow.iwm.cbor')
        await createIWI()
        await createIWM()
      }
      main()
    </script>
  </body>
</html>
